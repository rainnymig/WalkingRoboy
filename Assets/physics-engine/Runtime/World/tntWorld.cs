using UnityEngine;
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using PhysicsAPI;

enum COLLISION_EVENT_TYPE
{
    COLLISION_IVALID = -1,
    COLLISION_ENTER = 0,
    COLLISION_STAY = 1,
    COLLISION_EXIT = 2,
};

public enum SolverFidelityIndex
{
    Default = 0,
    HighFidelity = 1,
};

/**
 * @brief Structure for used by APE to expose information about a single collision
 */
public struct CollisionInfo 
{
    public int m_flag; // 0 - enter, 1 - stay, 2 - exit
    public UInt32 m_iThisColliderWorldIndex; // highest bit indicates if this is link or rigid body, 0 - link, 1 - rigidbody
    public UInt32 m_iOtherColliderWorldIndex; // highest bit indicates if this is link or rigid body, 0 - link, 1 - rigidbody
    public int m_iContactPointsBufferIndex; // use to index a separated contact points buffer
    public int m_iContactPointsBufferLength; 
    public Vector3 m_vImpulse;
    public Vector3 m_vRelativeVelocity;
};

/**
 * @brief Structure used by APE to expose information about a single contact point
 */
public struct ContactPointInfo
{
    public Vector3 m_vPosition;
    public Vector3 m_vNormal;
};

public class ExtendedContactPoint
{
    public Vector3 normal;
    public Vector3 point;
};

public struct PhysicsStatsInfo
{
    public int numActiveRigidBodies;
    public int numSleepRigidBodies;
    public int numActiveArticulations;
    public int numSleepArticulations;
    public int numActiveIslands;
    public int numSleepIslands;
    public int numRigidBodyConstraints;
    public int numArticulationConstraints;
    public int numIslandGroupingFeatures;
};

/**
 * @brief Modified version of Unity Collision used by APE
 */
public class ExtendedCollision : Collision
{
    new public ExtendedContactPoint[] contacts; // The contact points generated by the physics engine
    new public GameObject gameObject; //The GameObject whose collider we are colliding with
    new public Vector3 impulse; // The total impulse applied to this contact pair to resolve the collision
    new public Vector3 relativeVelocity; // The relative linear velocity of the two colliding objects
    new public tntRigidBody rigidbody; //The Rigidbody we hit. This is null if the object we hit is a collider with no rigidbody attached.
    new public Transform transform; // The Transform of the object we hit 
};

public interface ITntCollisionListenerBase { }

public interface ITntCollisionListener : ITntCollisionListenerBase
{
    void OnTntCollisionEnter(Collision collision);
    void OnTntCollisionStay(Collision collision);
    void OnTntCollisionExit(Collision collision);
}

public interface ITntTriggerListener : ITntCollisionListenerBase
{
    void OnTntTriggerEnter(GameObject go);
    void OnTntTriggerStay(GameObject go);
    void OnTntTriggerExit(GameObject go);
}

public interface ITntTriggerExtendedListener : ITntCollisionListenerBase
{
    void OnTntTriggerExtendedEnter(Collision collision);
    void OnTntTriggerExtendedStay(Collision collision);
    void OnTntTriggerExtendedExit(Collision collision);
}

public struct CTntRayHitInfo
{
    public Vector3 baryCentricCoord;
    public float distance;
    public Vector2 lightmapCoord;
    public Vector3 normal;
    public Vector3 point;
    public Vector2 textureCoord;
    public GameObject gameObject;
    public int triangleIndex;
	public IntPtr hitBody;
	public IntPtr hitBase;
	public int hitLinkIndex;
}

public struct KinematicExecutor
{
    public Vector3 m_vPos; // world space
    public Quaternion m_qOrientation; // world space
    public int m_bKick;
};

public class SCollisionCallbackInfo
{
    public GameObject gameObj;
    public bool m_bIsTrigger;
    public List<ITntTriggerListener> m_TiggerCallbacks;
    public List<ITntTriggerExtendedListener> m_TiggerExtendedCallbacks;
    public List<ITntCollisionListener> m_CollisionCallbacks;

    public SCollisionCallbackInfo()
    {
        gameObj = null;
        m_bIsTrigger = false;
        m_TiggerCallbacks = null;
        m_TiggerExtendedCallbacks = null;
        m_CollisionCallbacks = null;
    }

    public SCollisionCallbackInfo(GameObject go, bool trigger, List<ITntTriggerListener> triggerCallbacks, List<ITntTriggerExtendedListener> triggerExtendedCallbacks, List<ITntCollisionListener> collisionCallbacks)
    {
        gameObj = go;
        m_bIsTrigger = false;
        m_TiggerCallbacks = triggerCallbacks;
        m_TiggerExtendedCallbacks = triggerExtendedCallbacks;
        m_CollisionCallbacks = collisionCallbacks;
    }
};

interface ITntWorldNotifier {
    // Called when the world is created
    void OnTntWorldCreated (tntWorld world);

    // Called when the world is about to be destroyed
    void OnTntWorldDestroying (tntWorld world);
}

/**
 * @brief Class representing APE's dynamic world
 */
public partial class tntWorld : MonoBehaviour {
	private IntPtr dynamicsWorld = IntPtr.Zero;
    private List<tntLink> links = new List<tntLink>();
    private List<tntController> controllers = new List<tntController>();
    private PhysicsStatsInfo m_PhysicsStatsInfo;
	private static tntWorld m_world;		// tntWorld should be a singleton

	public const int COLLISIONINFOBUFFERSIZE = 1024*100;
	public const int CONTACTPOINTSBUFFERSIZE = 1024*1024;
	private ContactPointInfo[] m_pContactPointsBuffer;
	private CollisionInfo[] m_pCollisionInfoBuffer;

	private int lockCount = 0;	
	public int m_maxSubSteps = 16;
	public int m_numSteps = 60;
    public float m_staticConvexDistMargin = 0.04f;
    public bool m_disableRandomness = false;
    public float m_defaultErp = 0.2f;
    public float m_targetClockRatio = 1.0f;
    public bool m_persistOnLoad = true;

    [HideInInspector]
    public int m_numIterations = 4;
    [HideInInspector]
    public bool m_directSolverEnabled = false;
    [HideInInspector, SerializeField]
    protected SolverFidelityIndex m_solverFidelityIndex = SolverFidelityIndex.Default;
    [HideInInspector]
    public Vector3 m_gravity = new Vector3(0, -9.8f, 0);

    private bool m_allowMultipleMultibodySplitsPerFrame = true;
    private bool m_removeMotorsAndLimitsOfBrokenOffLinks = true;

    public PhysicsStatsInfo PhysicsStatsInfo {
		get { return m_PhysicsStatsInfo; }
	}

    public int numSteps {
        get { return m_numSteps; }
    }

    public delegate void AboutToBeginATickHandler(float dt);
    public delegate void JustFinishedATickHandler();

    public AboutToBeginATickHandler OnAboutToBeginATick;
    public AboutToBeginATickHandler OnFinishedResettingKernelWorldCache;
    public JustFinishedATickHandler OnJustFinishedATick;
    private float m_localTimeDeltaAccumulator = 0.0f;
    private int m_simulationSteps = 0;
    private bool m_resetKernelWorldCachedBeforeNextTick = false;

    public float SimulationTime { get { return m_simulationSteps / (float)m_numSteps; } }

    public IntPtr worldInKernel { get { return dynamicsWorld; } }
		
#if (!UNITY_IPHONE && !UNITY_WEBGL) || UNITY_EDITOR
	// [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
	private delegate void DebugLogDelegate(string str);
	private DebugLogDelegate m_debugLog;
	private DebugLogDelegate m_errorLog;

	// Debug Log API only for OSX
	[DllImport (PhysicsAPI.TNT.KernalLibraryName)]
	private static extern void SetDebugFunction(DebugLogDelegate fp);
	[DllImport (PhysicsAPI.TNT.KernalLibraryName)]
	private static extern void SetErrorFunction(DebugLogDelegate fp);

	private void DebugLog(string str)
	{
		Debug.Log("[tntPhysics] " + str);
	}

	private void ErrorLog(string str)
	{
		Debug.LogError("[tntPhysics] " + str);
	}
#endif

    /**
     * Dynamic world contructor
     */
	tntWorld()
    {
       
	}
	
    public void Lock() { lockCount++; }
    public void Unlock() { lockCount--; }
    
    public IntPtr GetDynamicWorld() { return dynamicsWorld; }

    /**
     * Initializes dynamic world internals if it has not been done so far
     */
	public void EnsureDynamicWorld()
	{
#if (!UNITY_IPHONE && !UNITY_WEBGL) || UNITY_EDITOR
		m_debugLog = new DebugLogDelegate(DebugLog);
		SetDebugFunction(m_debugLog);
		m_errorLog = new DebugLogDelegate(ErrorLog);
		SetErrorFunction(m_errorLog);
#endif

		if (dynamicsWorld == IntPtr.Zero)
		{
            dynamicsWorld = TNT.apCreateDynamicsWorld(TNT.apNewPhysicsSdk(), m_numIterations, m_staticConvexDistMargin, m_defaultErp, m_disableRandomness);

            SetGravity(m_gravity);

            m_pCollisionInfoBuffer = new CollisionInfo[COLLISIONINFOBUFFERSIZE];
			m_pContactPointsBuffer = new ContactPointInfo[CONTACTPOINTSBUFFERSIZE];
			unsafe{
				fixed( ContactPointInfo* cpi = &m_pContactPointsBuffer[0] )
				fixed( CollisionInfo* ci = &m_pCollisionInfoBuffer[0] )
				{
					TNT.apSetCollisionInfoBuffers(ci, COLLISIONINFOBUFFERSIZE, cpi, CONTACTPOINTSBUFFERSIZE);
				}

                fixed( PhysicsStatsInfo* psi = &m_PhysicsStatsInfo )
                {
                    TNT.apSetStatsBuffer(psi);
                }
			}

			// initialize engine's collision matrix
			for (int i = 0; i < 32; i++)
			{
				for (int j = 0; j < 32; j++)
				{
					bool collide = !(Physics.GetIgnoreLayerCollision(i, j));
					TNT.apSetLayerCollision(i, j, collide);
				}
			}
		}

        SetDefaultSolverFidelityIndex(m_solverFidelityIndex);
#if (!UNITY_IOS && !UNITY_WEBGL && !UNITY_ANDROID) || UNITY_EDITOR
        TNT.nnSetModulePhysicsSdkHandle(TNT.apGetPhysicsSdk());
#endif
    }
		
	void Awake()
	{
		if(m_world == null)
		{
			m_world = this;
            if (m_persistOnLoad)
			    DontDestroyOnLoad(gameObject);

			EnsureDynamicWorld();
			//if (m_world == null)
				//m_world = GameObject.FindObjectOfType<tntWorld>();
		}
		else if(m_world != this)
		{
			Destroy(gameObject);
		}
	}
	
	public static void Assert(bool condition, string message = "")
	{
		if (!condition)
		{
			UnityEngine.Debug.LogError("Assert! " + message);
			UnityEngine.Debug.Break();
		}
	}

    void OnEnable () {
        tntRigidBody.UpdateToWorld (this);
        tntRigidBodyConstraint.UpdateToWorld (this);
    }

    void Start()
    {
		unsafe
		{
		  // Compiler assertions to ensure C# and engine share the same structure layout
            Assert(sizeof(bool) == 1, "sizeof(bool) != 1");
			Assert(sizeof(apJointFeedback) == 12, "sizeof(apJointFeedback) != 12");
		}
    }

    // we MUST call this function to update the collision matrix
    // directly calling Physics.IgnoreCollision() is forbidden!
    /**
     * Disable/enable collision detection between passed in layers
     * @param layer0 first layer index
     * @param layer1 second layer index
     * @param collide false to disable collision detection, true otherwise
     * @remark This function configures both Unity's layer collision matrix collision and APE
     * @remark We MUST call this function to update the collision matrix
     * @see http://docs.unity3d.com/Manual/LayerBasedCollision.html
     */
    public void IgnoreLayerCollision(int layer0, int layer1, bool collide)
    {
		Physics.IgnoreLayerCollision(layer0, layer1, collide); // update unity's internal collision matrix
        TNT.apSetLayerCollision(layer0, layer1, !collide); // udpate the engine's collision matrix, so we make them synchronized
    }
	
    /**
     * Removes the passed in rigid-body constraint from the dynamic world
     * @param constraint native pointer to the constraint
     */
	public void RemoveConstraint(IntPtr constraint)
	{
		TNT.apRemoveConstraint(dynamicsWorld, constraint);
	}

    internal void AddRigidBody (tntRigidBody rigidBody) {
        if (rigidBody.m_world != this) {
            Debug.LogError ("the same rigid body is attempted to add to two different worlds. ignored");
                    }

        if (/*FIXME:m_world != IntPtr.Zero ||*/ rigidBody.m_added || worldInKernel == IntPtr.Zero) {
            return;
                }

        rigidBody.m_world = this;

        // if the transform has been changes by other system before adding to the world
        // give it a chance to sync/serialize to the kernel
        bool recreated = false;
        if (rigidBody.transform.hasChanged || rigidBody.m_flag != 0) {
            rigidBody.transform.hasChanged = false;
            rigidBody.m_flag |= tntRigidBody.Flag.Transform;
            recreated = true; //FIXME: this is faster than apSetPosAndRot
            }

        if (!tntEntityAndJointFactory.CreateRigidBody(rigidBody, recreated)) {
            m_world = null;
            Debug.Log ("Fail to create rigid body", this);
            return;
        } else if (rigidBody.m_rigidBody == IntPtr.Zero) {
            return; // compound child, won't create
        }
        // FIXME: remove recreated
        // SyncToKernel (m_world);

        //TNT.apSetRigidBodyMass(m_world, m_rigidBody, mass);
        TNT.apAddRigidBody (
            worldInKernel, rigidBody.m_rigidBody, rigidBody.m_collidable, rigidBody.m_collidable ? rigidBody.gameObject.layer : -1);

        rigidBody.m_added = true;

        if (rigidBody.m_IsKinematic) {
            // need to set it when the world is ready
            rigidBody.ForceSetKinematic (m_world);
        }

        // m_joints won't be mutable because enable joints only
        // when the rigid body is aware of the joint's existence, 
        // where the joint is already being added to the list
        for (int i = 0; i < rigidBody.m_joints.Count; ++i) {
            rigidBody.m_joints[i].AddIfActive (this, recreated);
        }

        rigidBody.UpdateCollisionListeners();
        rigidBody.SetInitialVelocities();
    }

	public void RemoveRigidBody (tntRigidBody rigidBody) {

        rigidBody.RemoveAllCollisionListeners();

        // if m_rigidbody is nil, it will never be added
        if (!rigidBody.m_added || worldInKernel == IntPtr.Zero) {
            return;
	    }

        if (rigidBody.m_world != this)
        {
            Debug.LogError("tntRigidBody is removed from a different world, ignored");
            return;
        }

        TNT.apRemoveRigidBody (worldInKernel, rigidBody.m_rigidBody);

        // FIXME: remove joint
        rigidBody.m_added = false;
        for (int i = 0; i < rigidBody.m_joints.Count; ++i) {
            RemoveConstraint (rigidBody.m_joints[i]);
        }
	}
    internal void AddConstraint(tntRigidBodyConstraint joint)
    {
        if (joint.m_world != this)
        {
            Debug.LogError("the same joint is attempted to add to two different worlds. ignored");
        }

        if (/*FIXME: m_world != IntPtr.Zero || */ joint.m_added || worldInKernel == IntPtr.Zero || joint.m_constraint == IntPtr.Zero)
        {
            return;
        }

        if (!joint.AreBothRigidBodiesEnabled())
        {
            return;
        }

        joint.m_world = this;
        TNT.apAddConstraint(worldInKernel, joint.m_constraint, joint.m_disableSelfCollision);
        joint.m_added = true;
    }

    internal void RemoveConstraint(tntRigidBodyConstraint joint)
    {
        if (!joint.m_added || worldInKernel == IntPtr.Zero || joint.m_constraint == IntPtr.Zero)
        {
            return;
        }

        if (joint.m_world != this)
        {
            Debug.LogError("tntRigidBodyConstraint is removed from a different world, ignored");
            return;
        }

        TNT.apRemoveConstraint(worldInKernel, joint.m_constraint);
        joint.m_added = false;
    }

    /**
     * Adds the multibody to the physics world: this includes adding the base and all of its child links.
     * @remark Assumption: All articulation links are child game objects of the articulation base's parent game object (they're on the same scene graph branch).
     * @remark The link indices allocation algorithm guarantees that parents always have smaller indices than children
     */
    public void AddArticulationBase(tntBase baseLink)
    {
        if (!baseLink.m_articulationCreated || baseLink.m_base == IntPtr.Zero)
        {
            Debug.LogError("Skipped adding invalid articulation to the kernel!");
            return;
        }

        // for the record: changed the condition from m_world == this to baseLink.m_world == this ..
        // .. since it matches RemoveArticulationBase 
        // TODO: remove the comment in future commits
        if (baseLink.m_world != this)
        {
            Debug.LogError("Skipped adding articulation belonged to another world!");
            return;
        }

        if (!baseLink.m_added)
        {
            if (baseLink.m_isOutOfSim)
            {
                Lock();
                TNT.apAddOutOfSimArticulation(baseLink.m_base);
                baseLink.m_added = true;
                Unlock();
                return;
            }

            Lock();

            tntChildLink[] links = null;
            if (baseLink.transform.parent != null)
            {
                tntChildLink[] allChildLinks = baseLink.transform.parent.GetComponentsInChildren<tntChildLink>(false);
                links = System.Array.FindAll<tntChildLink>(allChildLinks, comp => comp.enabled);
            }

            bool[] collidable = new bool[links == null ? 1 : links.Length + 1];
            collidable[0] = baseLink.m_collidable;

            unsafe
            {
                fixed (bool* colArray = &collidable[0])
                {
                    TNT.apAddArticulation(worldInKernel, baseLink.m_base, colArray, baseLink.gameObject.layer);           // finalizes native multibody's memory alloc
                }
            }
            baseLink.SetLayerID(baseLink.gameObject.layer);
            baseLink.SetCollidable(baseLink.m_collidable);

            if (links != null)
            {
                for (int i = 0; i < links.Length; ++i)
                {
                    tntChildLink link = links[i];
                    if (!link.ArePivotsMatching())
                        Debug.LogWarning("tntChildLink: '" + link.name + "' PivotA location doesn't match PivotB location (fixable with Auto Fill or manually).");
                    if (!isLinkUsable(link))
                        break;

                    link.SetLayerID(link.gameObject.layer);
                    link.SetCollidable(link.m_collidable);
                    for (int j = 0; j < link.m_dofData.Length; ++j)
                    {
                        tntDofData dofData = link.m_dofData[j];
                        if (dofData.m_useMotor)
                            link.AddMotor(j, dofData.m_isPositionMotor, dofData.m_desiredVelocity,
                                          dofData.m_desiredPosition, dofData.m_maxMotorForce, dofData.m_positionLockThreshold, dofData.m_useAutomaticPositionLockThreshold);
                        if (dofData.m_useLimit)
                            link.AddLimits(j, dofData.m_limitLow, dofData.m_limitHigh,
                                           dofData.m_maxLimitForce);
                    }
                }
            }

            if (baseLink.transform.parent != null)
            {
                tntController[] controllers = baseLink.transform.parent.GetComponentsInChildren<tntController>();
                foreach (tntController controller in controllers)
                {
                    if (!controller.enabled)
                        continue;
                    if (controller.SerializeToEngine())
                    {
                        AddController(controller);
                        TNT.acRegisterController(controller.GetEngineController());
                    }
                }
            }
            baseLink.m_added = true;

            Unlock();
        }
    }

    private static bool isLinkUsable(tntChildLink link)
    {
        if (link.mass == 0)
        {
            Debug.LogError("tntChildLink is skipped: '" + link.name + "' mass is set to 0. Please set it to a different value.");
            return false;
        }
        // FIXME it should be refactored since this kind of logic should be bound to e.g. ColliderFactory and not leaked in a random place like that
        Collider[] colliders = link.GetComponents<Collider>();
        tntCollider[] tntColliders = link.GetComponents<tntCollider>();
        if ((colliders.Length + tntColliders.Length) == 0)
        {
            Debug.LogError("tntChildLink is skipped: '" + link.name + "' there are no colliders. Please add one.");
            return false;
        }
        if ((colliders.Length + tntColliders.Length) > 1)
        {
            Debug.LogError("tntChildLink is skipped: '" + link.name + "' there's more than one collider. Please remove the unnecessary ones.");
            return false;
        }
        return true;
    }

    /**
     * Removes this base's multibody from the dynamic world
     */
    public void RemoveArticulationBase(tntBase baseLink)
    {
        Assert(baseLink.m_world == this, "Removing an articulation from another world");
        // TBD:  Remove articulation links and motor constraints
        if (baseLink.m_added && baseLink.m_articulationCreated && baseLink.m_base != IntPtr.Zero)
        {
            if (baseLink.transform.parent != null)
            {
                tntController controller = baseLink.transform.parent.GetComponentInChildren<tntController>();
                if (controller != null)
                {
                    controller.Cleanup();
                    RemoveController(controller);
                }

                tntChildLink[] links = null;
                links = baseLink.transform.parent.GetComponentsInChildren<tntChildLink>(false);
                if (links != null)
                {
                    for (int i = 0; i < links.Length; ++i)
                    {
                        links[i].m_added = false;
                    }
                }
            }

            TNT.apRemoveArticulation(worldInKernel, baseLink.GetBase());
            baseLink.m_added = false;
        }
    }

    /**
     * Registers the passed in link in tntWorld
     * @param link the link to be registered
     * @remark It's not the same as adding it to the dynamic world!
     * @see tntLink::SetWorldIndex
     * @remark This is registration in world which happens on Creation/Destruction
     */
    public void AddArticulationLink(tntLink link)
	{
		link.SetWorldIndex(links.Count);
		links.Add(link);
	}

    /**
     * Unregisters the passed in link in tntWorld (note: it's not the same as removing it from the dynamic world!)
     * @param link the link to be unregistered
     * @see tntLink::SetWorldIndex
     * @remark This is registration in world which happens on Creation/Destruction
     */
    public void RemoveArticulationLink(tntLink link)
	{
		// TBD: Move these to an IntrusiveList implementation
		int index = link.GetWorldIndex();
		if (index < 0)
		{
			return;
		}
		link.SetWorldIndex(-1);
		if (index < links.Count - 1)
		{
			links[index] = links[links.Count - 1];
			links[index].SetWorldIndex(index);
		}
		links.RemoveAt(links.Count - 1);
	}

    // desiredVelocity, desiredPosition : in radian
    /**
     * Adds a 1-degree-of-freedom joint motor to a multibody link
     * @param articulationBase native pointer to the base of a multibody this link is a part of
     * @param index index of a link the motor will drive
     * @param dof degree of freedom the motor will drive
     * @param isPositionMotor indicates whether the added motor is positional or velocity-based
     * @param desiredVelocity target velocity for positional and velocity motors
     * @param desiredPosition target position/angle for positional motors
     * @param maxForce force limit for the motor
     * @return native pointer to a mobilizer associated with the link
     * @remark angular values are expected to be provided in radians
     */
	public IntPtr AddMotor(IntPtr articulationBase, int index, int dof, bool isPositionMotor,
                           float desiredVelocity, float desiredPosition, float maxForce,
                           float positionLockThreshold, bool useAutomaticPositionLockThreshold)
	{
        return TNT.apAddMotor(dynamicsWorld, articulationBase, index, dof,
                                          desiredVelocity, desiredPosition,
                                          maxForce, isPositionMotor,
                                          positionLockThreshold, useAutomaticPositionLockThreshold);
	}

    /**
     * Removes a 1-degree-of-freedom joint motor from a multibody link
     * @param mobilizer native pointer to a mobilizer associated with the link
     * @param dof degree-of-freedom this motor drives
     */
	public void RemoveMotor(IntPtr mobilizer, int dof)
	{
		TNT.apDeleteMotor(dynamicsWorld, mobilizer, dof);
	}

    /**
     * Adds a 1-degree-of-freedom joint limit to a multibody link
     * @param articulationBase native pointer to the base of a multibody this link is a part of
     * @param index index of a link the wish to restrain
     * @param dof degree of freedom the limit will restrain
     * @param limitLow lower limit on allowable position/angle range
     * @param limitHigh upper limit on allowable position/angle range
     * @param maxForce force limit for the limit
     * @return native pointer to a mobilizer associated with the link
     * @remark angular values are expected to be provided in radians
     */
    public IntPtr AddLimits(IntPtr articulationBase, int index, int dof,
                            float limitLow, float limitHigh, float maxForce)
    {
        return TNT.apAddJointLimits(dynamicsWorld, articulationBase, index, dof,
                                    limitLow, limitHigh, maxForce);
    }

    /**
     * Removes a 1-degree-of-freedom joint limit from a multibody link
     * @param mobilizer native pointer to a mobilizer associated with the link
     * @param dof degree-of-freedom this limit restrains
     */
    public void RemoveLimits(IntPtr mobilizer, int dof)
    {
        TNT.apDeleteJointLimits(dynamicsWorld, mobilizer, dof);
    }

    /**
     * Adds a point-to-point articulation constraint to the dynamic world
     * @param p2pLink tntP2PLink object representing the constrained in Unity scripts
     * @return native pointer to the underlying constraint
     */
    public unsafe IntPtr AddArticulationP2PConstraint(tntArticulationP2PConstraint p2pConstraint)
	{
		IntPtr constraint = IntPtr.Zero;
		unsafe
		{
			fixed(Vector3* pivotA = &p2pConstraint.m_pivotA)
			fixed(Vector3* pivotB = &p2pConstraint.m_pivotB)
			fixed(void* pFB = &p2pConstraint.m_feedback.m_appliedImpulse)
            {
                if (p2pConstraint.m_linkA.GetBase() == IntPtr.Zero)
                {
                    Debug.LogError("P2Plink linkA: " + p2pConstraint.m_linkA.name + " base is null");
                    return IntPtr.Zero;
                }
                if (p2pConstraint.m_useBodyB)
                {
                    constraint = TNT.apAddArticulationRigidBodyP2PLink(
                        dynamicsWorld,
                        p2pConstraint.m_linkA.GetBase(), p2pConstraint.m_linkA.GetIndex(),
                        p2pConstraint.m_bodyB.GetRigidBody(),
                        pivotA, pivotB, p2pConstraint.m_maxImpulse, p2pConstraint.m_breakingImpulse,
						pFB);
                } else
                {
					if (p2pConstraint.m_linkB.GetBase() == IntPtr.Zero)
					{
						Debug.LogError("P2Plink linkB: " + p2pConstraint.m_linkB.name + " base is null");
						return IntPtr.Zero;
					}
					constraint = TNT.apAddArticulationP2PLink(
                        dynamicsWorld,
                        p2pConstraint.m_linkA.GetBase(), p2pConstraint.m_linkA.GetIndex(),
                        p2pConstraint.m_linkB.GetBase(), p2pConstraint.m_linkB.GetIndex(),
                        pivotA, pivotB, p2pConstraint.m_maxImpulse, p2pConstraint.m_breakingImpulse,
						pFB);
                }
			}
		}
		return constraint;
	}


    /**
     * Adds a point-to-point articulation constraint to the dynamic world
     * @param p2pLink tntP2PLink object representing the constraint in Unity scripts
     * @return native pointer to the underlying constraint
     */
    public unsafe IntPtr AddScriptedP2PConstraint(tntScriptedP2PConstraint p2pConstraint)
    {
        IntPtr constraint = IntPtr.Zero;
        unsafe
        {
            fixed (Vector3* pivotA = &p2pConstraint.m_pivotA)
            fixed (Vector3* pivotB = &p2pConstraint.m_pivotB)
            fixed (void* pFB = &p2pConstraint.m_feedback.m_appliedImpulse)
            {

                if (p2pConstraint.m_useBodyB)
                {
                    constraint = TNT.apCreateP2PConstraint(
                        p2pConstraint.m_bodyB.GetRigidBody(), IntPtr.Zero,
                        pivotA, null,
                        p2pConstraint.m_maxImpulse, -1, 
                        pFB);
                    TNT.apAddConstraint(dynamicsWorld, constraint, true);
                }
                else
                {
                    tntLink baseLink = p2pConstraint.m_linkA == null ? p2pConstraint.m_linkB : p2pConstraint.m_linkA;
                    if (baseLink.GetBase() == IntPtr.Zero)
                    {
                        Debug.LogError("P2Plink: " + baseLink.name + " base is null");
                        return IntPtr.Zero;
                    }

                    constraint = TNT.apAddArticulationRigidBodyP2PLink(
                        dynamicsWorld,
                        baseLink.GetBase(), baseLink.GetIndex(),
                        IntPtr.Zero,
                        pivotA, pivotB,
                        p2pConstraint.m_maxImpulse, p2pConstraint.m_breakingImpulse,
                        pFB);
                }
            }
        }
        return constraint;
    }

    /**
     * Adds a fixed multibody constraint to the dynamic world
     * @param fixedConstraint tntArticulationFixedConstraint object representing the constraint in Unity scripts
     * @return native pointer to the underlying constraint
     */
    public unsafe IntPtr AddFixedMultibodyConstraint(tntArticulationFixedConstraint fixedConstraint)
    {
        IntPtr constraint = IntPtr.Zero;
        unsafe
        {
            fixed (Vector3* pivotA = &fixedConstraint.m_pivotA)
            fixed (Vector3* pivotB = &fixedConstraint.m_pivotB)
            fixed (void* pFB = &fixedConstraint.m_feedback.m_appliedImpulse)
            {
                if (fixedConstraint.m_useBodyB)
                {
                    constraint = TNT.apAddArticulationRigidBodyFixedConstraint(
                        dynamicsWorld,
                        fixedConstraint.m_linkA.GetBase(), fixedConstraint.m_linkA.GetIndex(),
                        fixedConstraint.m_bodyB ? fixedConstraint.m_bodyB.GetRigidBody() : IntPtr.Zero,
                        pivotA, pivotB, fixedConstraint.m_maxImpulse, fixedConstraint.m_breakingImpulse,
                        pFB);
                }
                else
                {
                    if (fixedConstraint.m_linkA.GetBase() == IntPtr.Zero)
                    {
                        Debug.LogError("FixedConstraint linkA: " + fixedConstraint.m_linkA.name + " base is null");
                        return IntPtr.Zero;
                    }
                    if (fixedConstraint.m_linkB.GetBase() == IntPtr.Zero)
                    {
                        Debug.LogError("FixedConstraint linkB: " + fixedConstraint.m_linkB.name + " base is null");
                        return IntPtr.Zero;
                    }
                    constraint = TNT.apAddArticulationFixedConstraint(
                        dynamicsWorld,
                        fixedConstraint.m_linkA.GetBase(), fixedConstraint.m_linkA.GetIndex(),
                        fixedConstraint.m_linkB.GetBase(), fixedConstraint.m_linkB.GetIndex(),
                        pivotA, pivotB, fixedConstraint.m_maxImpulse, fixedConstraint.m_breakingImpulse,
                        pFB);
                }
            }
        }
        return constraint;
    }

    /**
     * Removes a multibody constraint and releases its memory
     * @param constraint native pointer to the underlying constraint
     */
	public void RemoveArticulationConstraint(IntPtr constraint)
	{
		TNT.apRemoveArticulationConstraint(dynamicsWorld, constraint);
        TNT.apDeleteArticulationConstraint(dynamicsWorld, constraint);
	}

    public void AddController(tntController controller)
    {
        controller.SetWorldIndex(controllers.Count);
        controllers.Add(controller);
    }

    public void RemoveController(tntController controller)
    {
        int index = controller.GetWorldIndex();
        if (index < 0)
        {
            return;
        }
        controller.SetWorldIndex(-1);
        if (index < controllers.Count - 1)
        {
            controllers[index] = controllers[controllers.Count - 1];
            controllers[index].SetWorldIndex(index);
        }
        controllers.RemoveAt(controllers.Count - 1);
    }

    /**
    * Synchronizes all needed world articulation links' positions and rotations from dynamic world internals to Unity 
    */
    void PullNeededArticulationTransformsFromKernel()
    {
        foreach (var link in links)
        {
            var baseLink = link as tntBase;
            if (baseLink != null)
            {
                baseLink.PullNeededTransformsFromKernel();
            }
        }
    }

    /**
    * Synchronizes all needed world articulation links' positions and rotations from Unity to dynamic world internals
    */
    void PushNeededArticulationTransformsToKernel()
    {
        foreach (var link in links)
        {
            var baseLink = link as tntBase;
            if (baseLink != null && baseLink.GetKinematic())
            {
                baseLink.PushNeededTransformsToKernel();
            }
        }
    }

    tntRigidBody GetCollisionCallbackInfo(int worldIndex, bool isRigidBody, ref SCollisionCallbackInfo CCI)
    {
        tntEntity entity = isRigidBody ? tntRigidBody.ByIndex(worldIndex) : entity = links[worldIndex];

        bool isTrigger = entity.GetShadowedTriggerFlag();
        CCI.gameObj = entity.gameObject;
        CCI.m_bIsTrigger = isTrigger;
        CCI.m_TiggerCallbacks = entity.m_triggerListeners;
        CCI.m_TiggerExtendedCallbacks = entity.m_triggerExtendedListeners;
        CCI.m_CollisionCallbacks = entity.m_collisionListeners;

        return isRigidBody ? entity as tntRigidBody : null;
    }

    GameObject FindGameObject(int worldIndex, bool isRigidBody)
    {
        if (isRigidBody)
        {
            tntRigidBody rb = tntRigidBody.ByIndex(worldIndex);
            if (rb)
                return rb.gameObject;
        }
        else
        {
            tntLink lk = links[worldIndex];
            if (lk)
                return lk.gameObject;
        }
        return null;
    }

    static void Swap<T>(ref T a, ref T b)
    {
        T tmp = a;
        a = b;
        b = tmp;
    }

    void ConstructCollisionInfoAndInvokeOnCollisionCallback(int indexToCollisionInfoBuffer, ref SCollisionCallbackInfo thisCCI, ref SCollisionCallbackInfo otherCCI, ref ExtendedCollision ec)
    {
        CollisionInfo ci = m_pCollisionInfoBuffer[indexToCollisionInfoBuffer];
        int thisColliderIndex = (int)(ci.m_iThisColliderWorldIndex & (~0xc0000000u));
        int otherColliderIndex = (int)(ci.m_iOtherColliderWorldIndex & (~0xc0000000u));
        bool isThisColliderRigidBody = ( (ci.m_iThisColliderWorldIndex & 0x80000000u) != 0 );
        bool isOtherColliderRigidBody = ( (ci.m_iOtherColliderWorldIndex & 0x80000000u) != 0 );
        bool isThisColliderListener = ( (ci.m_iThisColliderWorldIndex & 0x40000000u) != 0 );
        bool isOtherColliderListener = ( (ci.m_iOtherColliderWorldIndex & 0x40000000u) != 0 );
        COLLISION_EVENT_TYPE eventType = (COLLISION_EVENT_TYPE)ci.m_flag;

        //Debug.Log ("Issue collision callback for index=" + indexToCollisionInfoBuffer + "between worldIndex:" + thisColliderIndex +
        //           " isRB:" + isThisColliderRigidBody + "  and worldIndex:" + otherColliderIndex + " isRB:" + isOtherColliderRigidBody);
        tntRigidBody thisRB = GetCollisionCallbackInfo(thisColliderIndex, isThisColliderRigidBody, ref thisCCI);
        tntRigidBody otherRB = GetCollisionCallbackInfo(otherColliderIndex, isOtherColliderRigidBody,ref otherCCI);
        //return;
        for (int iteration = 0; iteration < 2; iteration++)
        {
            if (iteration == 1)
            {
                Swap(ref thisCCI, ref otherCCI);
                Swap(ref isThisColliderListener, ref isOtherColliderListener);
                Swap(ref thisRB, ref otherRB);
            }

            // check if it is listener
            if (!isThisColliderListener)
                continue;

            // check if it is trigger
            bool isTrigger = thisCCI.m_bIsTrigger;

            // grab the callbacks
            List<ITntTriggerListener> triggerCallbacks = thisCCI.m_TiggerCallbacks;
            List<ITntTriggerExtendedListener> triggerExtendedCallbacks = thisCCI.m_TiggerExtendedCallbacks;
            List<ITntCollisionListener> collisionCallbacks = thisCCI.m_CollisionCallbacks;

            if ( (isTrigger && (triggerCallbacks. Count == 0 && triggerExtendedCallbacks.Count == 0)) || (!isTrigger && collisionCallbacks.Count == 0) )
                continue;

            if (!isTrigger || (isTrigger && triggerExtendedCallbacks.Count != 0))
            {
                // impulse
                ec.impulse = (iteration == 1) ? -ci.m_vImpulse : ci.m_vImpulse;
                // relativeVelocity
                ec.relativeVelocity = (iteration == 1) ? -ci.m_vRelativeVelocity : ci.m_vRelativeVelocity;

                // gameObject
                ec.gameObject = otherCCI.gameObj;
                  
                // rigidbody
                if (isOtherColliderRigidBody)
                {
                    ec.rigidbody = otherRB;
                }
                else
                {
                    ec.rigidbody = null;
                }
                ec.transform = ec.gameObject.transform;

                // contacts
                if ( (eventType != COLLISION_EVENT_TYPE.COLLISION_EXIT) && (ci.m_iContactPointsBufferIndex >= 0) )
                {
                    ec.contacts = new ExtendedContactPoint[ci.m_iContactPointsBufferLength];
                    for (int j = 0; j < ci.m_iContactPointsBufferLength; j++)
                    {
                        ContactPointInfo cpi = m_pContactPointsBuffer[ci.m_iContactPointsBufferIndex+j];
                        ec.contacts[j] = new ExtendedContactPoint();
                        ec.contacts[j].normal = (iteration == 1) ? -cpi.m_vNormal : cpi.m_vNormal;
                        ec.contacts[j].point = cpi.m_vPosition;
                    }
                }
            }

            // invoke the callbacks
            switch (eventType)
            {
                case COLLISION_EVENT_TYPE.COLLISION_ENTER:
                    if (isTrigger)
                    {
                        foreach (var l in triggerCallbacks) l.OnTntTriggerEnter(otherCCI.gameObj);
                        foreach (var l in triggerExtendedCallbacks) l.OnTntTriggerExtendedEnter(ec);
                    }
                    else
                        foreach (var l in collisionCallbacks) l.OnTntCollisionEnter(ec);
                    break;
                case COLLISION_EVENT_TYPE.COLLISION_STAY:
                    if (isTrigger)
                    {
                        foreach (var l in triggerCallbacks) l.OnTntTriggerStay(otherCCI.gameObj);
                        foreach (var l in triggerExtendedCallbacks) l.OnTntTriggerExtendedStay(ec);
                    }
                    else
                        foreach (var l in collisionCallbacks) l.OnTntCollisionStay(ec);
                break;
            case COLLISION_EVENT_TYPE.COLLISION_EXIT :
                    if (isTrigger)
                    {
                        foreach (var l in triggerCallbacks) l.OnTntTriggerExit(otherCCI.gameObj);
                        foreach (var l in triggerExtendedCallbacks) l.OnTntTriggerExtendedExit(ec);
                    }
                    else
                        foreach (var l in collisionCallbacks) l.OnTntCollisionExit(ec);
                break;
            }
        }
    }

	void Update()
	{
        if (lockCount > 0 || dynamicsWorld == IntPtr.Zero)
            return;

        int nControllers = controllers.Count;
        for (int i = 0; i < nControllers; ++i)
		{
			tntController controller = controllers[i];
			controller.SyncWithEngine();
			controller.UpdateDebugVisualizers();
            controller.UpdateControllerState();
		}

        // Verify all tntRopeJoints are connected to valid bodies.
        tntRopeJoint.VerifyRopesHaveValidBodies();

        // Add rigid bodies to the world and sync data to the kernel if needed
        // Run the deferred commands on the physics thread
        tntRigidBody.UpdateToWorld (this);
        tntRigidBodyConstraint.UpdateToWorld (this);
        PushNeededArticulationTransformsToKernel();

        float fixedTimeStep = 1.0f / (float)m_numSteps;
        float dt = Time.deltaTime;
        int maxSubSteps = m_maxSubSteps;

        m_localTimeDeltaAccumulator += dt * m_targetClockRatio;
        if (m_localTimeDeltaAccumulator >= fixedTimeStep)
        {
            int numSteps = Mathf.FloorToInt(m_localTimeDeltaAccumulator / fixedTimeStep);
            m_localTimeDeltaAccumulator -= numSteps * fixedTimeStep;

            numSteps = numSteps < maxSubSteps ? numSteps : maxSubSteps;

            for (int step = 0; step < numSteps; ++step, ++m_simulationSteps)
            {
                if (OnAboutToBeginATick != null)
                    OnAboutToBeginATick(fixedTimeStep);

                if (m_resetKernelWorldCachedBeforeNextTick)
                {
                    TNT.apResetDynamicsWorldCaches(dynamicsWorld);
                    m_resetKernelWorldCachedBeforeNextTick = false;
                }

                if (OnFinishedResettingKernelWorldCache != null)
                    OnFinishedResettingKernelWorldCache(fixedTimeStep);

                TNT.apStepSimulation(dynamicsWorld, fixedTimeStep, 0, 0.0f);

                if (OnJustFinishedATick != null)
                    OnJustFinishedATick();
            }
        }        

        // the null'd bodies will be referenced in the collision callbacks
        // the index will stay valid until the end of frame
        var nullBodies = tntRigidBody.FetchTransform (this);
        PullNeededArticulationTransformsFromKernel();
        UpdateBrokenJoints(!m_allowMultipleMultibodySplitsPerFrame);

        SCollisionCallbackInfo CCI1 = new SCollisionCallbackInfo();
        SCollisionCallbackInfo CCI2 = new SCollisionCallbackInfo();
        ExtendedCollision ec = new ExtendedCollision();
        UInt32 totalNum = m_pCollisionInfoBuffer[0].m_iThisColliderWorldIndex;
        //Debug.Log("collision info num : " + totalNum);

        for (int i = 1; i < totalNum + 1; i++)
        {
            ConstructCollisionInfoAndInvokeOnCollisionCallback(i, ref CCI1, ref CCI2, ref ec);
        }

        m_pCollisionInfoBuffer [0].m_iThisColliderWorldIndex = 0;
		CCI1 = null;
		CCI2 = null;

        // clean up the null'd bodies
        tntRigidBody.RemoveLast (nullBodies);
    }


/*
	void FixedUpdate()
	{
        TNT.apStepSimulation(dynamicsWorld, Time.fixedDeltaTime, m_maxSubSteps, 1.0f / (float)m_numSteps);

        for (int i = 0; i < bodies.Count; ++i)
        {
            bodies[i].transform.position = bodies[i].m_position;
            bodies[i].transform.rotation = bodies[i].m_rotation;
            //Debug.Log ("Updated body#" + i + " pos = " + bodies[i].m_position + "rot = " + bodies[i].m_rotation);
        }

        for (int i = 0; i < links.Count; ++i)
        {
            links[i].transform.position = links[i].m_position;
            links[i].transform.rotation = links[i].m_rotation;
            //Debug.Log ("Updated body#" + i + " pos = " + bodies[i].m_position + "rot = " + bodies[i].m_rotation);
        }
	}
*/

    /**
     * Destroys underlying dynamic world internals
     */
    void RemoveDynamicWorld()
    {
        for(int i = links.Count - 1; i >= 0; --i)
        {
            tntBase baseLink = links[i] as tntBase;
            if (baseLink != null)
            {
                RemoveArticulationBase(baseLink);  // Base removal will remove all child links from engine
                tntEntityAndJointFactory.DestroyArticulationBase(baseLink);

                // the links that are removed doesn't seem to moved to the end of list all the time
                i = Math.Min(i, links.Count);
            }
        }
        links.Clear ();

        if (dynamicsWorld != IntPtr.Zero) {
        TNT.apDeleteDynamicsWorld(dynamicsWorld);
    }
        dynamicsWorld = IntPtr.Zero;
    }

    void OnDestroy() {
        tntRigidBodyConstraint.WorldIsRemoved (this);
        tntRigidBody.WorldIsRemoved (this);
        RemoveDynamicWorld();
    }

    /**
     * Sets gravitational acceleration for the dynamics world
     * @param gravity gravitational acceleration vector
     */
    public void SetGravity(Vector3 gravity)
    {
        m_gravity = gravity;
        if (dynamicsWorld != IntPtr.Zero)
        {
            unsafe
            {
                TNT.apSetGravity(dynamicsWorld, &gravity);
            }
        }
    }

    /**
     * Returns gravitational acceleration for the dynamics world
     * @return gravity gravitational acceleration vector
     */
    public Vector3 GetGravity()
    {
        Vector3 gravity;

        unsafe
        {
            TNT.apGetGravity(dynamicsWorld, &gravity);
        }

        return gravity;
    }

    public void SetConstraintSolverIterationCount(int numIterations)
    {
        m_numIterations = Math.Max(0, numIterations);
        if (m_world != null)
            TNT.apSetDynamicsWorldSolverIterationsNumber(dynamicsWorld, numIterations);
    }

    public bool ResetKernelWorldCachedBeforeNextTick
    {
        get { return m_resetKernelWorldCachedBeforeNextTick; }
        set { m_resetKernelWorldCachedBeforeNextTick = value; }
    }

    [Obsolete("Please use DefaultSolverFidelityIndex property instead")]
    public void EnableDirectSolver(bool enable)
    {
        Debug.LogWarning("tntWorld.EnableDirectSolver(bool) called - This method is obsolete.");
        m_directSolverEnabled = enable;
        if (m_world != null)
            TNT.apEnableDirectSolver(dynamicsWorld, enable);
    }

    private void SetDefaultSolverFidelityIndex(SolverFidelityIndex fidelityIndex)
    {
        m_solverFidelityIndex = fidelityIndex;
        if (dynamicsWorld != IntPtr.Zero)
        {
            TNT.apSetDefaultSolverFidelityIndex(dynamicsWorld,(int) fidelityIndex);
        }
    }

    public SolverFidelityIndex DefaultSolverFidelityIndex
    {
        get { return m_solverFidelityIndex; }
        set
        {
            if (value != m_solverFidelityIndex)
            {
                SetDefaultSolverFidelityIndex(value);
            }
        }
    }

    static public int GetNumberOfAvailableSolverFidelityIndices()
    {
        return TNT.apGetNumberOfAvailableFidelityIndices();
    }
}
